#!/usr/bin/env python3
#
# Copyright 2024 Canonical Ltd.
#
# Construct a launcher file that describes the test session that will
# carried out on the DUT
#
# Dependencies:
#
#
# Usage:
#     `build_checkbox_launcher`

from argparse import ArgumentParser
from io import StringIO
import configparser
import json
import os

# Top of the launcher file - used by all runs
launcher_head = """
[launcher]
launcher_version = 1
stock_reports = text, submission_files

[daemon]
normal_user = ubuntu

[ui]
type = silent
auto_retry = yes
max_attempts = 3
delay_before_retry = 15

[transport:example_c3]
type = submission-service
secure_id = \$HEXR_DEVICE_SECURE_ID

[transport:example_local_file]
type = file
path = /home/ubuntu/c3-local-submission.tar.xz

[exporter:example_tar]
unit = com.canonical.plainbox::tar

[report:report_example_c3]
transport = example_c3
exporter = example_tar
forced = yes

[report:report_example_file]
transport = example_local_file
exporter = example_tar
forced = yes
"""

# The test plan selection sections of the launcher
checkbox_launcher_sru = """
#!/usr/bin/env checkbox-cli
[test plan]
unit = {checkbox_testplan}
forced = yes

[test selection]
forced = yes
exclude = com.canonical.certification::clevis-encrypt-tpm2* com.canonical.certification::stress/poweroff* com.canonical.certification::stress/reboot* .*miscellanea/ubuntu-desktop-recommends .*bluetooth_obex_send {exclude_test}
"""

checkbox_launcher_sru_no_stress = """
#!/usr/bin/env checkbox-cli
[test plan]
unit = {checkbox_testplan}
forced = yes

[test selection]
forced = yes
exclude = .*disk/disk_stress_ng_.* .*stress/cpu_stress_ng_test .*pts/fs-mark .*pts/ramspeed .*s3_pm-graph_30 .*s2idle_pm-graph_30 .*pts/cpuminer-opt com.canonical.certification::clevis-encrypt-tpm2* com.canonical.certification::stress/poweroff* com.canonical.certification::stress/reboot* .*miscellanea/ubuntu-desktop-recommends .*bluetooth_obex_send {exclude_test}
"""

checkbox_launcher_smoke = """
#!/usr/bin/env checkbox-cli
[test plan]
unit = com.canonical.certification::smoke
forced = yes

[test selection]
forced = yes
exclude = .*smoke/manual {exclude_test}
"""

# any config that needs modifying per device
# cat <<EOF > device_conf.tmpl
# {checkbox_conf}
# EOF
# cheetah fill --env device_conf.tmpl -p > device_conf


fallback_manifest = """
[manifest]
com.canonical.certification::has_bt_smart = false
com.canonical.certification::has_camera = true
com.canonical.certification::has_card_reader = true
com.canonical.certification::has_ethernet_adapter = true
com.canonical.certification::has_thunderbolt = false
com.canonical.certification::has_thunderbolt3 = false
com.canonical.certification::has_touchscreen = false
com.canonical.certification::has_tpm2_chip = false
com.canonical.certification::has_usb_storage = true
com.canonical.certification::has_usb_type_c = false
com.canonical.certification::has_wlan_adapter = true
"""


def parse_json(manifest_file_path):
    """
    Given an manifest json file, parse it as a format suitable for the Checkbox launcher file
    """

    with open(manifest_file_path) as file:
        manifest_dict = dict(json.load(file))

    manifest_ini = StringIO()
    print("[manifest]", end="\n", file=manifest_ini)
    for key, value in manifest_dict.items():
        line = f"{key} = {value}"
        print(line, end="\n", file=manifest_ini)
    return manifest_ini.getvalue()


def build_checkbox_launcher():
    parser = ArgumentParser(
        prog="",
        description="",
    )
    parser.add_argument("job_variant", type=str)
    parser.add_argument("cid", type=str)
    parser.add_argument("testplan_id", type=str)
    parser.add_argument("manifest_dir", type=str)
    args = parser.parse_args()

    manifest_file_path = os.path.join(
        args.manifest_dir, "pc", args.cid, "manifest.json"
    )
    print("Expected manifest path: {}".format(manifest_file_path))
    if os.path.exists(manifest_file_path):
        print("Print found manifest")
        manifest_conf = parse_json(manifest_file_path)
    else:
        print("Manifest not found, using default")
        manifest_conf = fallback_manifest

    if args.job_variant == "no_stress":
        launcher_test_selection = checkbox_launcher_sru_no_stress.format(
            checkbox_testplan=args.testplan_id, exclude_test=""
        )
    elif args.job_variant == "smoke":
        launcher_test_selection = checkbox_launcher_smoke.format(
            checkbox_testplan=args.testplan_id, exclude_test=""
        )
    else:  # implies "full"
        launcher_test_selection = checkbox_launcher_sru.format(
            checkbox_testplan=args.testplan_id, exclude_test=""
        )

    # Merge the launcher we downloaded with checkbox.conf

    c = configparser.ConfigParser(delimiters=("=",))
    c.optionxform = str
    c.read_string(launcher_head)
    c.read_string(launcher_test_selection)
    # c.read('device_conf')
    c.read_string(manifest_conf)
    c.write(open("checkbox-launcher", "wt"))
    print("Wrote checkbox-launcher")


if __name__ == "__main__":
    build_checkbox_launcher()
