#!/usr/bin/env python3
#
# Copyright 2024 Canonical Ltd.
#
# Construct a launcher file that describes the test session that will
# carried out on the DUT
#
# Dependencies:
#
#
# Usage:
#     `build_checkbox_launcher`

from argparse import ArgumentParser
from io import StringIO
import configparser
import json
import os
import requests

# This is base template of the checkbox launcher file that will be constructed
# Other sections or overrides to these values will be applied on top of this
# file using ConfigParser processing
launcher_head = """
[launcher]
launcher_version = 1
stock_reports = text, submission_files

[daemon]
normal_user = ubuntu

[ui]
type = silent
auto_retry = yes
max_attempts = 3
delay_before_retry = 15

[transport:example_c3]
type = submission-service
secure_id = \$HEXR_DEVICE_SECURE_ID

[transport:example_local_file]
type = file
path = /home/ubuntu/c3-local-submission.tar.xz

[exporter:example_tar]
unit = com.canonical.plainbox::tar

[report:report_example_c3]
transport = example_c3
exporter = example_tar
forced = yes

[report:report_example_file]
transport = example_local_file
exporter = example_tar
forced = yes
"""

# The next three static strings are applied on top the base launcher depending on the jenkins job
# parameter "TESTPLAN", the options provided are full, no_stress, smoke
# This is made more complicated by the fact that the test plan itself can also that be modified
# per project
checkbox_launcher_sru = """
[test plan]
unit = {checkbox_testplan}
forced = yes

[test selection]
forced = yes
exclude = com.canonical.certification::clevis-encrypt-tpm2* com.canonical.certification::stress/poweroff* com.canonical.certification::stress/reboot* .*miscellanea/ubuntu-desktop-recommends .*bluetooth_obex_send {exclude_test}
"""

checkbox_launcher_sru_no_stress = """
[test plan]
unit = {checkbox_testplan}
forced = yes

[test selection]
forced = yes
exclude = .*disk/disk_stress_ng_.* .*stress/cpu_stress_ng_test .*pts/fs-mark .*pts/ramspeed .*s3_pm-graph_30 .*s2idle_pm-graph_30 .*pts/cpuminer-opt com.canonical.certification::clevis-encrypt-tpm2* com.canonical.certification::stress/poweroff* com.canonical.certification::stress/reboot* .*miscellanea/ubuntu-desktop-recommends .*bluetooth_obex_send {exclude_test}
"""

checkbox_launcher_smoke = """
[test plan]
unit = com.canonical.certification::smoke
forced = yes

[test selection]
forced = yes
exclude = .*smoke/manual {exclude_test}
"""

# This the environment that all machines will use if we cannot find one specifically create for that
# machine
fallback_environment = """
[environment]
ROUTERS = multiple
WPA_BG_SSID = cert-bg-wpa-tel-l3-01
WPA_BG_PSK = insecure
WPA_N_SSID = cert-n-wpa-tel-l3-01
WPA_N_PSK = insecure
WPA_AC_SSID = cert-ac-wpa-tel-l3-01
WPA_AC_PSK = insecure
WPA_AX_SSID = cert-ax-wpa-tel-l3-01
WPA_AX_PSK = insecure
WPA3_AX_SSID = cert-ax-wpa3-tel-l3-01
WPA3_AX_PSK = insecure
OPEN_BG_SSID = cert-bg-open-tel-l3-01
OPEN_N_SSID = cert-n-open-tel-l3-01
OPEN_AC_SSID = cert-ac-open-tel-l3-01
OPEN_AX_SSID = cert-ax-open-tel-l3-01
BTDEVADDR = 54:35:30:15:BC:DA
TRANSFER_SERVER = cdimage.ubuntu.com
DISPLAY= :0
SUDO_USER = ubuntu
STRESS_NG_DISK_TIME = 15
STRESS_NG_CPU_TIME = 60
PTS_CACHE_URL = http://10.102.196.9/sru/phoronix_cache/
SNAPD_TASK_TIMEOUT = 120
ZAPPER_HOST = \$ZAPPER_IP
"""


# This is the manifest that all machines will use if we cannot find one specifically created for that
# machine
fallback_manifest = """
[manifest]
com.canonical.certification::has_bt_smart = false
com.canonical.certification::has_camera = true
com.canonical.certification::has_card_reader = true
com.canonical.certification::has_ethernet_adapter = true
com.canonical.certification::has_thunderbolt = false
com.canonical.certification::has_thunderbolt3 = false
com.canonical.certification::has_touchscreen = false
com.canonical.certification::has_tpm2_chip = false
com.canonical.certification::has_usb_storage = true
com.canonical.certification::has_usb_type_c = false
com.canonical.certification::has_wlan_adapter = true
"""


def parse_json(manifest_json):
    """
    Given an manifest json file, parse it as a format suitable for the Checkbox launcher file
    """
    manifest_ini = StringIO()
    print("[manifest]", end="\n", file=manifest_ini)
    for key, value in manifest_json.items():
        line = f"{key} = {value}"
        print(line, end="\n", file=manifest_ini)
    return manifest_ini.getvalue()


def build_checkbox_launcher():
    parser = ArgumentParser(
        prog="",
        description="",
    )
    parser.add_argument("job_variant", type=str)
    parser.add_argument("cid", type=str)
    parser.add_argument("testplan_id", type=str)
    parser.add_argument("extra_excludes", type=str)
    # parser.add_argument("manifest_dir", type=str)
    parser.add_argument("secure_id", type=str)
    args = parser.parse_args()

    # The overlay for manifest should come from the shared repo
    # this sections attempts to find one at the path supplied
    # and use a suitable default otherwise
    # manifest_file_path = os.path.join(
    #     args.manifest_dir, "pc", args.cid, "manifest.json"
    # )

    print("Fetching Manifest from C3")
    response = requests.get(
        f"https://certification.canonical.com/api/v2/machines/{args.cid}/manifest?secure_id={args.secure_id}"
    )
    if response.status_code == 200:
        print("Found manifest")
        manifest_conf = parse_json(response.json())
    else:
        print("Manifest not found, using default")
        manifest_conf = fallback_manifest

    # The overlay for configuration/environment should come from the shared repo
    # this sections attempts to find one at the path supplied
    # and use a suitable default otherwise
    # configuration_file_path = os.path.join(
    #     args.manifest_dir, "pc", args.cid, "checkbox.conf"
    # )
    # print("Expected configuration path: {}".format(configuration_file_path))
    # if os.path.exists(configuration_file_path):
    #     print("Print found configuration")
    #     environment_conf = parse_json(manifest_file_path)
    # else:
    #     print("Configuration not found, using default")
    environment_conf = fallback_environment

    if args.job_variant == "no_stress":
        launcher_test_selection = checkbox_launcher_sru_no_stress.format(
            checkbox_testplan=args.testplan_id, exclude_test=args.extra_excludes
        )
    elif args.job_variant == "smoke":
        launcher_test_selection = checkbox_launcher_smoke.format(
            checkbox_testplan=args.testplan_id, exclude_test=args.extra_excludes
        )
    else:  # implies "full"
        launcher_test_selection = checkbox_launcher_sru.format(
            checkbox_testplan=args.testplan_id, exclude_test=args.extra_excludes
        )

    # Build up the final checkbox launcher by overlaying the various layers
    # built up above
    c = configparser.ConfigParser(delimiters=("=",))
    c.optionxform = str
    c.read_string(launcher_head)
    c.read_string(launcher_test_selection)
    c.read_string(environment_conf)
    c.read_string(manifest_conf)
    c.write(open("checkbox-launcher", "wt"))
    print("Wrote checkbox-launcher")


if __name__ == "__main__":
    build_checkbox_launcher()
