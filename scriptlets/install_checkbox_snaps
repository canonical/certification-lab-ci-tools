#!/bin/bash

# Install Checkbox on the DUT and the agent
#
# Description:
#
# Installs Checkbox snap (runtime + frontend) on the DUT. Also installs
# Checkbox on the agent from source matching the version on the DUT
# Finally the installation on the DUT is verified to check that the machine is
# ready to run tests.
# The `risk` parameter can be either "stable", "beta", "edge" and is used for
#   both runtime and frontend
# The `frontend_name` can be any of the frontend snaps (eg. checkbox,
#   checkbox-tillamook).
# The `frontend_track` parameter can be any valid track name (eg. 22.04, uc16).
#   It is also used to appropriately install the snap (decide if a snap is
#   classic or strict)


get_ubuntu_arch() {
    declare -A arch_map=([x86_64]=amd64 [aarch64]=arm64 [armv7l]=armhf [i686]=i386)
    echo "${arch_map[$(uname -m)]:-$(uname -m)}"
}

find_runtime() {
  # get the store token from the device, if available
  STORE=$(_run "snap model --assertion" | sed -n 's/^store:\s\(.*\)$/\1/p')
  # get the snap info from the snap store and extract the base
  # (to be used as a heuristic for deriving the Checkbox runtime)
  BASE=$(curl -s -H 'Snap-Device-Series: 16' ${STORE:+ -H "Snap-Device-Store: $STORE"} "https://api.snapcraft.io/v2/snaps/info/$FRONTEND_NAME?fields=base" \
  | jq -r --arg FRONTEND_TRACK $FRONTEND_TRACK --arg RISK $RISK '.["channel-map"] | .[] | select(.channel.track == $FRONTEND_TRACK and .channel.risk == $RISK) | .base')
  if [ "$BASE" = "null" ]; then
    # no base:" resort to using the Core version
    # (the final "grep ." will cause the command to fail if there's no match)
    RUNTIME_NAME="checkbox$(cat /etc/os-release | sed -n 's/PRETTY_NAME="Ubuntu Core \([0-9]\{2\}\)"$/\1/p' | grep .)"
  elif [ "$BASE" = "core" ]; then
    # base: core -> runtime: checkbox16
    RUNTIME_NAME=checkbox16
  else
    # base coreYY -> runtime checkboxYY
    # (the final "grep ." will cause the command to fail if there's no match)
    RUNTIME_NAME="checkbox$(echo $BASE | sed -n 's/^core\([0-9]\{2\}\)$/\1/p' | grep .)"
  fi
  echo $RUNTIME_NAME
}

set -e

if [[ "$#" != "3" ]]; then
  echo "Usage: $(basename ${BASH_SOURCE[0]}) risk frontend_name frontend_track"
  exit 1
fi

echo "Installing Checkbox snaps"

RISK=$1
FRONTEND_NAME=$2
FRONTEND_TRACK=$3
FRONTEND_CHANNEL="$FRONTEND_TRACK/$RISK"

# get the store token from the device, if available
STORE=$(_run "snap model --assertion" | sed -n 's/^store:\s\(.*\)$/\1/p')

echo "DIAGNOSTIC: Store info $STORE"
curl -s -H 'Snap-Device-Series: 16' ${STORE:+ -H "Snap-Device-Store: $STORE"} "https://api.snapcraft.io/v2/snaps/info/$FRONTEND_NAME?fields=base" 

# get the snap info from the snap store and extract the base
BASE=$(curl -s -H 'Snap-Device-Series: 16' ${STORE:+ -H "Snap-Device-Store: $STORE"} "https://api.snapcraft.io/v2/snaps/info/$FRONTEND_NAME?fields=base&architecture=$(get_ubuntu_arch)" \
| jq -r --arg FRONTEND_TRACK $FRONTEND_TRACK --arg RISK $RISK '.["channel-map"] | .[] | select(.channel.track == $FRONTEND_TRACK and .channel.risk == $RISK) | .base')

echo "DIAGNOSTIC: BASE=$BASE"

# use the base as a heuristic to derive the Checkbox runtime
if [ "$BASE" = "null" ]; then
  # no base:" resort to using the Core version
  # (the final "grep ." will cause the command to fail if there's no match)
  RUNTIME_NAME="checkbox$(cat /etc/os-release | sed -n 's/PRETTY_NAME="Ubuntu Core \([0-9]\{2\}\)"$/\1/p' | grep .)"
elif [ "$BASE" = "core" ]; then
  # base: core -> runtime: checkbox16
  RUNTIME_NAME=checkbox16
else
  # base coreYY -> runtime checkboxYY
  # (the final "grep ." will cause the command to fail if there's no match)
  RUNTIME_NAME="checkbox$(echo $BASE | sed -n 's/^core\([0-9]\{2\}\)$/\1/p' | grep .)"
fi
echo "DIAGNOSTIC: RUNTIME_NAME=$RUNTIME_NAME"

# RUNTIME_NAME=$(find_runtime)
RUNTIME_CHANNEL="latest/$RISK"

echo "Installing runtime snap: $RUNTIME_NAME from $RUNTIME_CHANNEL"
_run sudo snap install --no-wait $RUNTIME_NAME --channel=$RUNTIME_CHANNEL
wait_for_snap_changes

# install the frontend snap as a strict snap and revert to classic if that fails
# (strict snaps need a different install flag and the connections to be made)
echo "Installing frontend snap: $FRONTEND_NAME from $FRONTEND_CHANNEL (as a strict snap, using --devmode)"
STRICT_FRONTEND=true
_run sudo snap install --no-wait $FRONTEND_NAME --devmode --channel=$FRONTEND_CHANNEL
if [ "$?" -ne 0 ]; then
    echo "Failed to install $FRONTEND_NAME as a strict snap"
    echo "Installing frontend snap: $FRONTEND_NAME from $FRONTEND_CHANNEL (as a classic snap, using --classic)"
    STRICT_FRONTEND=false
    _run sudo snap install --no-wait $FRONTEND_NAME --classic --channel=$FRONTEND_CHANNEL
fi
wait_for_snap_changes

# run the configure hook of the frontend snap
_run sudo snap set $FRONTEND_NAME agent=enabled
# note: setting "slave" instead of "agent" has been deprecated but is still necessary for some snaps
_run sudo snap set $FRONTEND_NAME slave=enabled

# start the service
_run sudo snap start $FRONTEND_NAME

if $STRICT_FRONTEND; then
    # these are the default plugs (although some custom frontends may not have them)
    CONNECTIONS="checkbox-runtime provider-checkbox provider-resource provider-certification-client"
    # these are the actual plugs for this frontend
    FRONTEND_PLUGS=$(_run "snap connections $FRONTEND_NAME" | awk '{ print $2 }' | tail +2)
    # iterate over the default plugs...
    for CONNECTION in $CONNECTIONS; do
        # ... and connect them to the corresponding slot in the runtime, if the plug exists
        if echo "$FRONTEND_PLUGS" | grep -q "^$FRONTEND_NAME:$CONNECTION$"; then
            _run sudo snap connect $FRONTEND_NAME:$CONNECTION $RUNTIME_NAME:$CONNECTION
        fi
    done

    # these plugs are not automatically connected but are necessary to run some tests
    # (we are handling results on a per-interface basis because we may not need
    # these interfaces if we don't run the tests they are required for)
    set +e
    # network tests
    _run sudo snap connect $FRONTEND_NAME:network-manager network-manager:service \
    || echo "Failed to connect plug. Networking (mostly wifi) tests may not work"
    # bluetooth tests
    _run sudo snap connect $FRONTEND_NAME:bluez bluez:service \
    || echo "Failed to connect plug. Bluetooth tests may not work"
    _run sudo snap connect $FRONTEND_NAME:bluetooth-control core:bluetooth-control \
    || echo "Failed to connect plug. Bluetooth tests may not work"
    set -e
fi

# some versions of snapd seem to force dependencies to be stable in some situation
# but we want RISK risk, so lets force it by re-installing it
# Note: this is done twice because if snapd doesn't force the stable dependency
#       then this causes just 1 download
_run sudo snap refresh --no-wait $RUNTIME_NAME --channel=latest/$RISK
wait_for_snap_changes

# restart the service, to make sure the latest version of the code is used
_run sudo snap restart $FRONTEND_NAME

export CHECKBOX_VERSION=$(_run $FRONTEND_NAME.checkbox-cli --version)
[ -z "$CHECKBOX_VERSION" ] && echo "Error: Unable to retrieve Checkbox version from device" && exit 1

echo "Installing checkbox $CHECKBOX_VERSION on the agent container from source"
install_checkbox_agent_source $CHECKBOX_VERSION

check_for_checkbox_service --debug
