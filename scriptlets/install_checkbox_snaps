#!/bin/bash

# Install Checkbox on the DUT and the agent
#
# Description:
#
# Installs Checkbox snap (runtime + frontend) on the DUT. Also installs
# Checkbox on the agent from source matching the version on the DUT
# Finally the installation on the DUT is verified to check that the machine is
# ready to run tests.
# The `risk` parameter can be either "stable", "beta", "edge" and is used for
#   both runtime and frontend
# The `frontend_name` can be any of the frontend snaps (eg. checkbox,
#   checkbox-tillamook).
# The `frontend_track` parameter can be any valid track name (eg. 22.04, uc16).
#   It is also used to appropriately install the snap (decide if a snap is
#   classic or strict)


get_ubuntu_arch() {
    declare -A arch_map=([x86_64]=amd64 [aarch64]=arm64 [armv7l]=armhf [i686]=i386)
    UNAME_ARCH=$(_run "uname -m")
    echo "${arch_map[$UNAME_ARCH]:-$UNAME_ARCH}"
}

get_runtime() {
    # get the store token from the device, if available
    STORE=$(_run "snap model --assertion" | sed -n 's/^store:\s\(.*\)$/\1/p')
    # get the snap info from the snap store and extract the base
    SNAPSTORE_URL="https://api.snapcraft.io/v2/snaps/info/$FRONTEND_NAME?fields=base"
    SNAPINFO=$(curl -s -H 'Snap-Device-Series: 16' ${STORE:+ -H "Snap-Device-Store: $STORE"} "$SNAPSTORE_URL")
    BASE=$(jq -r \
      --arg FRONTEND_TRACK $FRONTEND_TRACK \
      --arg RISK $RISK \
      --arg ARCH $(get_ubuntu_arch) \
      '.["channel-map"] | .[] |
       select(
         .channel.track == $FRONTEND_TRACK and
         .channel.risk == $RISK and
         .channel.architecture == $ARCH
        ) |
        .base' <<< $SNAPINFO
    )
    # use the base as a heuristic to derive the Checkbox runtime
    if [ "$BASE" = "null" ]; then
      # no base:" fall back to using the Core version
      # (the final "grep ." will cause the command to fail if there's no match)
      RUNTIME_NAME="checkbox$(_run "cat /etc/os-release" | sed -n 's/PRETTY_NAME="Ubuntu Core \([0-9]\{2\}\)"$/\1/p' | grep .)"
    elif [ "$BASE" = "core" ]; then
      # base: core -> runtime: checkbox16
      RUNTIME_NAME=checkbox16
    else
      # base coreYY -> runtime checkboxYY
      # (the final "grep ." will cause the command to fail if there's no match)
      RUNTIME_NAME="checkbox$(echo $BASE | sed -n 's/^core\([0-9]\{2\}\)$/\1/p' | grep .)"
    fi
    echo $RUNTIME_NAME
}

connect() {
    CONNECTIONS=$(_run "snap connections --all")
    echo "$CONNECTIONS" | awk '
        # Collect unconnected frontend plugs
        $2 ~ "^'"$FRONTEND_NAME"':" && $3 == "-" {
            match($2, "^'"$FRONTEND_NAME"':(.+)", matches);
            plug_name = matches[1];
            plugs[plug_name] = 1;
        }
        # Collect unconnected runtime slots
        $3 ~ "^'"$RUNTIME_NAME"':" && $2 == "-" {
            match($3, "^'"$RUNTIME_NAME"':(.+)", matches);
            slot_name = matches[1];
            slots[slot_name] = 1;
        }
        END {
            # Connect frontend plugs to matching runtime slots
            for (plug_name in plugs) {
                if (plug_name in slots) {
                    plug = "'"$FRONTEND_NAME"':" plug_name;
                    slot = "'"$RUNTIME_NAME"':" plug_name;
                    print "Connecting " plug " to " slot;
                    system("snap connect " plug " " slot);
                }
            }
        }
    '
    echo "$CONNECTIONS" | awk '
        # Collect unconnected non-content frontend plugs
        $2 ~ "^'"$FRONTEND_NAME"':" && $3 == "-" && $1 != "content" {
            interface = $1;
            match($2, "^'"$FRONTEND_NAME"':(.+)", matches);
            plug_name = matches[1];
            plugs[plug_name] = interface;
        }
        # Collect all non-content slots by interface
        $3 ~ ":" {
            interface = $1;
            if (interface != "content") {
                slots[interface] = $3;
            }
        }
        END {
            # Connect frontend plugs to slots on matching interfaces
            for (plug_name in plugs) {
                interface = plugs[plug_name];
                if (interface in slots) {
                    plug = "'"$FRONTEND_NAME"':" plug_name;
                    slot = slots[interface];
                    print "Connecting " plug " (" interface ") to " slot;
                    system("snap connect " plug " " slot);
                }
            }
        }
    '
}


set -e

if [[ "$#" != "3" ]]; then
  echo "Usage: $(basename ${BASH_SOURCE[0]}) risk frontend_name frontend_track"
  exit 1
fi

log "Installing Checkbox snaps"

export RISK=$1
export FRONTEND_NAME=$2
export FRONTEND_TRACK=$3
FRONTEND_CHANNEL="$FRONTEND_TRACK/$RISK"
RUNTIME_NAME=$(get_runtime)
RUNTIME_CHANNEL="latest/$RISK"

echo "Installing runtime snap: $RUNTIME_NAME from $RUNTIME_CHANNEL"
_run sudo snap install --no-wait $RUNTIME_NAME --channel=$RUNTIME_CHANNEL
wait_for_snap_changes

# install the frontend snap as a strict snap and revert to classic if that fails
# (strict snaps need a different install flag and the connections to be made)
echo "Installing frontend snap: $FRONTEND_NAME from $FRONTEND_CHANNEL (as a strict snap, using --devmode)"
STRICT_FRONTEND=true
_run sudo snap install --no-wait $FRONTEND_NAME --devmode --channel=$FRONTEND_CHANNEL
if [ "$?" -ne 0 ]; then
    echo "Failed to install $FRONTEND_NAME as a strict snap"
    echo "Installing frontend snap: $FRONTEND_NAME from $FRONTEND_CHANNEL (as a classic snap, using --classic)"
    STRICT_FRONTEND=false
    _run sudo snap install --no-wait $FRONTEND_NAME --classic --channel=$FRONTEND_CHANNEL
fi
wait_for_snap_changes

# run the configure hook of the frontend snap
_run sudo snap set $FRONTEND_NAME agent=enabled
# note: setting "slave" instead of "agent" has been deprecated but is still necessary for some snaps
_run sudo snap set $FRONTEND_NAME slave=enabled

if $STRICT_FRONTEND; then
    connect
fi

# some versions of snapd seem to force dependencies to be stable in some situation
# but we want RISK risk, so lets force it by re-installing it
# Note: this is done twice because if snapd doesn't force the stable dependency
#       then this causes just 1 download
_run sudo snap refresh --no-wait $RUNTIME_NAME --channel=latest/$RISK
wait_for_snap_changes

# restart the service, to make sure the latest version of the code is used
_run sudo snap restart $FRONTEND_NAME

export CHECKBOX_VERSION=$(_run $FRONTEND_NAME.checkbox-cli --version)
[ -z "$CHECKBOX_VERSION" ] && log --error "Unable to retrieve Checkbox version from device" && exit 1

log "Installing checkbox $CHECKBOX_VERSION on the agent container from source"
install_checkbox_agent_source $CHECKBOX_VERSION

check_for_checkbox_service --debug
