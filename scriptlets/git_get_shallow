#!/usr/bin/env bash

# Perform a light, shallow fetch of a single commit or branch from a repo

# disable tracing (if previously enabled)
[[ "$-" == *x* ]] && TRACING=true && set +x || TRACING=false

usage() {
    echo "Usage: $(basename ${BASH_SOURCE[0]}) <repository> [commit [<commit_ref>]]"
    echo "Usage: $(basename ${BASH_SOURCE[0]}) <repository> branch <branch>"
}

# parse command-line arguments

if [[ "$#" -lt 1 ]]; then
    echo "Error: no repository specified"
    usage
    exit 1
fi

REPO="$1"
shift

COMMIT_DEFAULT="HEAD"
COMMIT=""
BRANCH=""
while [[ "$#" -gt 0 ]]; do
    case $1 in
        commit)
            if [ -z "$COMMIT" ]; then
                if [ -n "$2" ]; then
                    COMMIT=$2
                    shift
                else
                    COMMIT="$COMMIT_DEFAULT"
                fi
            else
                echo "Error: commit already specified"
                usage
                exit 1
            fi
            ;;
        branch)
            if [ -z "$BRANCH" ]; then
                if [ -n "$2" ]; then
                    BRANCH=$2
                    shift
                else
                    echo "Error: value required for branch"
                    usage
                    exit 1
                fi
            else
                echo "Error: branch already specified"
                usage
                exit 1
            fi
            ;;
        *)
            echo "Error: Invalid argument $1";
            usage
            exit 1
            ;;
    esac
    shift
done
if [ -n "$COMMIT" -a -n "$BRANCH" ]; then
    echo "Error: cannot specify both a commit and a branch"
    usage
    exit 1
fi

# main functionality

COMMIT="${COMMIT:-$COMMIT_DEFAULT}"
REPO_PATH=$(basename $REPO .git)

if [ -z "$BRANCH" ]; then
    echo "Fetching $REPO@$COMMIT into $REPO_PATH"
    mkdir -p "$REPO_PATH"
    git -C "$REPO_PATH" init --quiet
    git -C "$REPO_PATH" fetch --quiet --depth 1 "$REPO" "$COMMIT" \
    && git -C "$REPO_PATH" reset --hard FETCH_HEAD
else
    echo "Cloning $REPO@$BRANCH into $REPO_PATH"
    rm -rf $REPO_PATH \
    && git clone --quiet --depth 1 --branch "$BRANCH" "$REPO" $REPO_PATH \
    && git -C "$REPO_PATH" show --oneline -s HEAD
fi

# restore tracing (if previously enabled)
[ "$TRACING" = true ] && set -x || true
